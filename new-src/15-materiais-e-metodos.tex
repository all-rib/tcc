\chapter{Materiais e Métodos}

\section{Materiais}

O desenvolvimento da plataforma de sensoriamento foi realizado com
base em uma arquitetura modular, composta por sensores ambientais,
microcontroladores e módulos de comunicação sem fio. Os principais
materiais utilizados foram:

\begin{itemize}
	\item \textbf{Sensores ambientais:} utilizados para medir temperatura, umidade, pressão e som, permitindo o monitoramento das condições internas e externas das colmeias.
	\item \textbf{Microcontrolador:} o LORA32 (uma variante do ESP32) foi empregado devido à sua conectividade bluetooth e capacidade de armazenamento externo..
	\item \textbf{Componentes eletrônicos auxiliares:} reguladores de tensão, e cabos blindados foram utilizados para garantir robustez elétrica em condições adversas.
	\item \textbf{Softwares e ferramentas:} o firmware e bibliotecas foram desenvolvidos em C utilizando o \textit{ESP-IDF}. O projeto de hardware foi elaborado no \textit{KiCad}.
\end{itemize}

\section{Métodos}

O método adotado para o desenvolvimento do sistema foi estruturado em
etapas sucessivas, partindo da concepção do protótipo até os testes
preliminares de funcionamento.

Inicialmente, foi definida a arquitetura geral do sistema, composta
por sensores instalados na colmeia e interfaceados com I2C, além de um
posterior cliente bluetooth para transmissão e recepção de dados e
comandos remotamente. O módulo coleta informações ambientais e as
escreve em armazenamento externo para posterior análise.

A segunda etapa consistiu na integração dos sensores com o
microcontrolador. Foram realizados testes de leitura e calibração,
seguidos pela implementação do firmware recomendado pelos fabricantes,
para a coleta e registro periódico de dados. Para mitigar falhas de
comunicação, foram incluídas rotinas de reinicialização automática e
verificação de conectividade.

Os sensores foram conectados em pares, sendo um interno e outro
externo à colmeia, com o objetivo de capturar o contraste térmico
entre os ambientes. A arquitetura adotada utilizou endereçamento I²C
para múltiplos dispositivos de mesmo tipo, conforme
configuração de endereço 0x76/0x77.  Os dados coletados foram
armazenados localmente em arquivo texto com formatação para posterior análise.

A terceira etapa concentrou-se nos testes de bancada, com foco na
estabilidade elétrica, consumo de energia e resposta dos sensores.
Embora não tenha sido possível realizar testes prolongados em campo,
os resultados preliminares permitiram identificar limitações e propor
soluções que são discutidas no capítulo seguinte.
















Conforme explicado capitulo anterior, os seguintes problemas puderam
ser observados:

Falhas de conexão estável nas conexões entre o microcontrolador e os
sensores, utilizadores da interface I2C;

Falhas dos sensores devido ao contato com material orgânico;

Drenagem de bateria devido à subsequente falhas do microcontrolador,
mesmo após rotinas de reset por watchdog;

Falta de memória para captura de eventos;

Impermeabilização interna dos sensores;

Captura de eventos/log mediante falhas, e impossibilidade de debug em
tempo real;

Custo de inserir chamadas para todo e qualquer evento do sistema;

Cada problema ser[a 

Considerando os objetivos do projeto, definiu-se as seguintes etapas:





  0 Uma solução é o registro de alguns pontos para futura correção:
  1 conjunto subsequente de chamadas que levou à execução até a instrução
  2 fatal (stack), um snapshot de pontos importantes da memória,
  3 memory-dump, eventos ocorridos, que possam ter provocado o erro,
  4 event-log, e por fim, características físicas do dispositivo, como
  5 temperatura, níveis de tensão e corrente, quando possível. Mas além de
  6 tudo isso, a função original de hard-fault precisa ser reescrita, de
  7 preferência a resetar o dispositivo.
  8 
  9 Para isso, a API padrão dos dispositivos ESP32 já possuem chamadas
 10 para geração de logs, capaz de apresentar mensagens conforme a demanda
 11 do usuário. Conforme explica [18], o sistema possui diversos níveis de
 12 log, onde, ao configurar os parâmetros Log Level e Maximum Log Level,
 13 podemos determinar quais mensagens aparecerão, variando, em ordem
 14 decrescente de verbosidade, Verbose, Debug e Info até Warning, Error e
 15 None.  Caso alguma mensagem seja configurada com uma verbosidade maior
 16 que Maximum Log Level, a mesma não constará no binário final.
 17 
 18 Essa habilidade, no entanto, exige uma tomada de decisão. A escrita
 19 dos eventos pode ser feita de duas maneiras: preditiva, isto é, nos possíveis
 20 pontos de problemas, sempre exportar mensagens; Ou remediativa, que é
 21 verificar o código por problemas, e caso encontrado, exportar a
 22 respectiva mensagem. O primeiro método possui o malefício de gerar
 23 mensagens desnecessárias e exigir muitos recursos dedicados ao log. A
 24 segunda opção, no entanto, possui a possibilidade de que um erro fatal
 25 impeça o dispositivo de continuar funcionando, e mensagem nenhuma ser
 26 registrada.










 Eventualmente, problemas na rotina do
microcontrolador drenaram a bateria. Em algumas
ocasiões, era possível capturar o erro antes da drenagem completa, mas
isso deu origem à
necessidade de criar um sistema robusto de logging de erros, uma vez
que erros do tipo hard-fault, por padrão, resultam num loop infinito
em determinado ponto do programa, e mesmo com uso de watchdog, o erro torna a
ocorrer, e intervenção do usuário é necessária. A ideia original, é que o usuário
seja capaz de debuggar e verificar o sistema no ponto de erro, seja rodando
o programa de trás pra frente, inspecionando a memória, stack, entre
outros recursos, mas essa informação fica sujeita à capacidade do
usuário de intervir no sistema em funcionamento, dificultado no
contexto desse trabalho.

	Uma solução é o registro de alguns pontos para futura
correção: conjunto subsequente de chamadas que levou à execução até a
instrução fatal (stack), um snapshot de pontos importantes da memória,
memory-dump, eventos ocorridos, que possam ter provocado o erro,
event-log, e por fim, características físicas do dispositivo, como
temperatura, níveis de tensão e corrente, quando possível. Mas além de
tudo isso, a função original de hard-fault precisa ser reescrita, de
preferência a resetar o dispositivo.

Essa habilidade, no entanto, exige uma tomada de decisão. A escrita
dos eventos pode ser feita de duas maneiras: preditiva, isto é, nos possíveis
pontos de problemas, sempre exportar mensagens; Ou remediativa, que é
verificar o código por problemas, e caso encontrado, exportar a
respectiva mensagem. O primeiro método possui o malefício de gerar
mensagens desnecessárias e exigir muitos recursos dedicados ao log. A
segunda opção, no entanto, possui a possibilidade de que um erro fatal
impeça o dispositivo de continuar funcionando, e mensagem nenhuma ser
registrada. 

% TODO: Deveria usar a ideia do Denardim, e criar uma região reservada
% para registro de logs?

% TODO: Ver como funciona o debug de um hard-fault dentro de um RTOS
 
	Para efeitos práticos, um wrapper foi criado para automatizar a
geração das mensagens de log, dando origem à uma biblioteca denominada
HERMES. Esse wrapper foi escrito de maneira que quaisquer ações
direcionadas a um sensor gerasse eventos, e os registrasse em
armazenamento de massa.

	A biblioteca possui o conceito de "object", ou "objeto", onde um objeto é
capaz de realizar determinadas tarefas, classificadas em inicializar,
configurar, consultar, e desinicializar. Essas tarefas são abstraídas
no conceito de "taskchain", ou "corrente de tarefas", onde um ou mais
métodos, ou funções, podem ser cadastradas na chain para realizar
chamadas subsequentes na ordem em que foram cadastradas. E para cada
nova chamada, um evento é gerado e armazenado.

	A captura dos dados foram feitas através de consulta sob demanda
de cada sensor, e gravação através do armazenamento utilizando uma função atômica de escrita, em um
arquivo de texto, seguindo um padrão de time-stamp

[#n][Nome]([medida][unidade])\\+

Esse padrão foi
utilizado por fornecer contexto de origem, instante e leitura de um
sensor, consideradas suficientes para a naturza desta aplicação.

	Além disso, a biblioteca foi implementada com uma análise de
requisitos, a saber

'''
* - Only it can write. Other actors must rely on this to write.
* 
* - Must write, no matter what happens (i.e. write must always
* succeed);
* 
* This means that if for any reason, the media fails to be written to,
* the actor must be able to hold-on information for long enough, or
* provide necessary means to easy the load of current write, until the
* write media goes back to normal;
* 
* - Must, while writing, lock any actor from reading it;
* 
* This is to prevent incomplete/inaccurate info retrieval (i.e. atomic
* write/read operations)
* 
* - Must, while reading, lock any actor from writing it;
* 
* - Must handle parallel writes/reads;
* 
* - Must generate its own events (be able to log itself in event-driven
* manner);
'''

	Dentre os requisitos, destacam se dois importantes: "Must write,
no matter what happens", essencial para a garantia de telemetria dos
sensores, e "must handle parallel writes/reads", conveniente à
implementação de diversos sensores para escrita e leitura simultânea.





% NOTE: Acho que não precisa da biblioteca de compactação, mas seria
% interessante falar que ela foi criada

	Para tratar do primeiro requisito, foi desenvolvida uma nova
biblioteca, afim de lidar com o problema de pouca memória presente no
micro, prevendo a possivel falha de todos os canais de comunicacoes do
sistema, por diversas razões.

	Para métodos de lidar com dados seriais, pode-se citar fila como
sendo a mais comum. A fila possui um modelo first-in, first out (FIFO)
de consulta, permitindo que n séries s de dados sejam capturados, e para
amostragem ser uniforme, os dados são amostrados numa frequencia f.

	No entanto, a lotação da memória por outros processos pode fazer
com que dados sejam perdidos, de forma que alguma série pode não ser
subsequente à outra. Para corrigir isso, uma opção é reduzir a
frequência de captura, por consequência diminuindo sua resolução, em
detrimento da garantia de captura de pelo menos um dado durante o
período em que a memória ficou lotada.

	Além disso, também é possivel o agrupamento dos dados em séries,
dado que os dados tem um intervalo bem definido de possilibdades,
bastando apenas guardar os instantes de tempo no qual o mesmo ocorre.

	Outro auxílio é possivel através do uso de média movel, para
garantia que os dados, ainda que esparços, sejam capazes de
representar a média de valores de um intervalo.

	Por fim, pode-se ainda compactar os valores, procedendo para
escrita numa mídia de armazenamento em massa, ou transmissão para
posterior consulta.

	A biblioteca, nomeada de Sparse-Buffer, possui todas as
funcionalidades citadas a cima, utilizada
	



A bateria acabar

Algum cabo falhar

Algum sensor falhar

	- como descobrir a diferença de falha do sensor, ou falha do cabo?
talvez testar um curto local

a rede falhar

 - como unificar os canais de rede em uma biblioteca só?

o armazenamento falhar











	Outro aspecto importante de pensar foi a forma de posicionar os
sensores.






Lembrar de falar que nao possuir osciloscopio disponivel em campo
dificultou muita coisa

Possivel efeito capacitivo do contato de circuito i2c com umidade

falar sobre hard-fault que engole energia no esp

falar sobre a necessidade de um debug remoto






% Achar um argumento melhor pra essa porra.


	Alem disso, a exposicao de eletronicos no mel é um assunto sem
publicações. No entanto, estende-se parte das implicações da presença
de umidade nessas aplicações.

	Um problema comum em I2C é sua sensibilidade a efeitos capacitivos
na linha

% https://www.eevblog.com/forum/projects/i2c-pcb-design-trace-length-and-interference/
%
% descobrir como a resistencia afeta o efeito de bordas na i2c

%Lembrar de falar que nao possuir osciloscopio disponivel em campo
%dificultou muita coisa

% Possivel efeito capacitivo do contato de circuito i2c com umidade

% falar sobre hard-fault que engole energia no esp

% falar sobre a necessidade de um debug remoto





[fotografia cabo de rede]

	Para consulta dos sensores, 

I2C



\subsection{Estudos}

\subsubsection{Temperatura}



\subsection{Aplicação e registro}
\subsection{Análise Comparativa}
















