Conforme explicado capitulo anterior, os seguintes problemas puderam
ser observados:

Falhas de conexão estável nas conexões entre o microcontrolador e os
sensores, utilizadores da interface I2C;

Falhas dos sensores devido ao contato com o mel;

Drenagem de bateria devido à subsequente falhas do microcontrolador,
mesmo após rotinas de reset por watchdog;

Falta de memória para captura de eventos;

Impermeabilização interna dos sensores;

Captura de eventos/log mediante falhas, e impossibilidade de debug em
tempo real;

Custo de inserir chamadas para todo e qualquer evento do sistema;

Cada problema ser[a 

Considerando os objetivos do projeto, definiu-se as seguintes etapas:

















Busca de metodologias de sensoriamento de abelhas A. mellifera,
considerando-se os dispositivos mais comumente utilizados (sensor de
temperatura, umidade, pressão, microfone, e luminosidade). A busca
será feita através de ScienceDirect e Scholar Google. Esta etapa
nomea-se Busca.

Estudo da natureza de ambas as abelhas, levantando considerações sobre
suas semelhanças e diferenças que podem interferir nos métodos
conforme disposições dos próprios artigos. Essa etapa nomeia-se
Estudos.

Aplicação dos métodos de monitoramento, e extração dos dados, em
colméias de T. angustula, observando principalmente a necessidade de
adaptação dos métodos e suas diferenças, para registro. Essa etapa
nomeia-se Aplicação e registro.

Observação dos resultados obtidos e comparação dos métodos,
levantando suas diferenças, e dificuldades do processo. Essa etapa
nomeia-se Análise-comparativa.

\subsection{Busca}

 Foram buscado os termos colméia, monitoramento, abelha, modelo,
sensoriamento, precisão, apicultura, observando-se suas respectivas traduções para o inglês
(honeycomb, monitoring, bee;honeybee, model, sensoring, precision,
apiculture,). Adiante
listam-se as considerações mais importantes encontradas.

[4] faz uma pesquisa extensiva nos mesmos tópicos, provendo uma
revisão de literatura abrangente sobre o assunto. Suas pesquisas citam
a importância da umidade para a saúde geral da colméia, e manutenção
das crias, regulação térmica, prevenção da proliferação de fungos e
bactérias, e preservação das propriedades do mel para consumo das
crias. Além disso, a temperatura possui funções semelhantes, de
maneira que a maioria das operarias realizam atividades para
manutenção constante dessas variáveis.

	Segundo a mesma autora, o som também possui uma enorme
importância, pois é um dos canais de comunicação para ações do enxame
como um todo, responsável pela transmissão de eventos (alertas sobre invasores, fontes de
alimento, intempéries climáticas) e comportamento sazonal (como
aumento de atividade de evaporação de umidade, ou enxameação). Outras
variáveis como peso e composição atmosférica também interferem nas
características de ruído da colméia.

Algumas metodologias de sensoriamento envolvem Machine Learning,
Análise de dados e visão computacional, a exemplo, [trindade,2018]
utiliza um sensor de temperatura e umidade, alem de celulas para medir
peso. Para transmissao dos dados, foi utilizado um dispositivo Xbee,
mas nao descreve detalhes sobre qualidade de sinal, ou mesmo sobre o
tipo de servidor utilizado, apontando apenas que os dados foram
processados utilizando-se microsoft excel.

	Estendendo a analise da obra de maneira hipotetica, pode se
estipular que parte da decisao de utilizar um dispositivo Xbee foi
devido a sua facilidade de conexao com a rede, por ser facilmente
interfaceavel com outros sistemas operacionais. Torna-se então
evidente a necessidade de um sinal de telefonia movel, ou sinal de
internet para a transmissao dos dados para nuvem.

	Alem disso, trabalhos como [ferrari,2008] possuem
uma taxa de captura muito maior de dados, estendendo não apenas
variáveis como temperatura e umidade, mas também microfone, e imagem,
o que cria um enorme fluxo de dados para serem processados,
inviabilizando o processamento local. Para endereçar esse problema,
armmazenimento externo será utilizado.

% TODO: Sera que preciso encontrar algo comprovando que a metodologia
% de sensoriamento exige ter uma amostra como sendo "normal", e outra
% de comparação?

	Portanto, percebe-se que um caminho para a criação de um perfil
pode envolver temperatura, som, umidade, pressão, características que
podem refletir eventos como a presença ou a falta de alimento [fonte],
a presença de predadores, níveis de saúde, e eventos específicos como
a enxameação. 

	Os sistemas idealmente precisam sensoriar ao menos um ponto
dentro, e um ponto fora da colmeia, permitindo assim observar o
contraste entre o ambiente externo e interno da colméia, um ponto
considerado "de controle", e o outro para análise comparativa.

	Para temperatura, foram os sht30, um externo e outro interno, e o
BME280. O SHT30, desenvolvido pela Sensirion, é um sensor digital de
temperatura e umidade relativa, ideal para
aplicações em sistemas embarcados. Ele utiliza comunicação via I²C com
suporte a verificação de integridade CRC, o que o torna confiável
mesmo em ambientes com interferência elétrica. Possui calibração de
fábrica, o que elimina a necessidade de ajustes manuais, e oferece
alta precisão, com erro típico de ±2\% para umidade relativa e ±0,3 °C
para temperatura. Com baixo consumo de energia e encapsulamento
compacto (DFN-6), o mesmo é amplamente utilizado em aplicações
industriais, automação residencial, dispositivos IoT e monitoramento
ambiental. Sua combinação de precisão, estabilidade e facilidade de
integração o torna uma escolha robusta e eficiente para projetos que
exigem sensoriamento ambiental confiável.

	Escolhidos pela disponibilidade e precisao, alem de possuírem um
sensor de umidade embarcado. seu tambanho também facilita o
posicitionamento em qualquer local da colmeia. O sensor possui
interface I2C, com velocidades de ate 1MHz, com acuracia de 1.5\% de
umidade relativa, e 0.1oc. Seu baixo consumo (1.5mA durante medicao, e
0.5uA em idle-mode) tambem e um fator
importante para a aplicacao, considerando que o dispositivo deve rodar
sem supervisao durante um grande periodo, utilizando baterias. Por
fim, o dispositivo nao necessita de calibracao.

No entanto, sua breakout board possui um circuito pequeno que pode
atrabalhar a insercao direta do sensor dentro da colmeia. Em
decorrencia de eventuais falhas, um foi posto do lado de fora, outro
do lado de dentro.

	Ao longo do projeto, problemas com o SHT30 me fizeram testar
também o sensor BME30


%TODO: revisar isso segundo datasheet()

	Para comparacao. e possibilidade de contato direto com o mel,
escolheu-se o DS18b20 por sua versatilivdade de encapsulamentos.

O DS18B20 é um sensor digital de temperatura fabricado pela Maxim
Integrated (atualmente parte da Texas Instruments), amplamente
utilizado em sistemas embarcados e aplicações industriais. Seu
destaque está na comunicação via 1-Wire, que permite a transmissão de
dados e alimentação por um único fio, simplificando o cabeamento em
sistemas distribuídos. O sensor oferece uma faixa de medição de -55 °C
a +125 °C, com precisão típica de ±0,5 °C na faixa entre -10 °C e
+85 °C, e resolução configurável de 9 a 12 bits. Além disso, cada
unidade possui um código único de 64 bits gravado de fábrica,
permitindo a identificação individual de múltiplos sensores conectados
em paralelo no mesmo barramento. Seu encapsulamento compacto (TO-92 ou
versões estanques em aço inox) e sua robustez tornam o DS18B20 ideal
para uso em ambientes externos, automação residencial, agricultura de
precisão e sistemas de monitoramento térmico distribuído.

	Para microfone, foi usado o INMP441, devido a disponibilidade,
familiaridade, e aplicacoes ja implementadas com esse mesmo
dispositivo. 

O INMP441 é um microfone digital do tipo MEMS
(Micro-Electro-Mechanical Systems), projetado para capturar sinais
acústicos com alta fidelidade e baixo ruído. Ele integra internamente
um conversor ADC de 24 bits e se comunica por meio da interface
digital I²S, permitindo a transmissão direta de áudio para
microcontroladores ou processadores de sinal sem a necessidade de
circuitos analógicos externos. O INMP441 apresenta uma faixa dinâmica
ampla e resposta em frequência plana, sendo capaz de captar sons entre
60 Hz e 15 kHz com boa sensibilidade. Sua arquitetura digital elimina
interferências comuns a microfones analógicos, tornando-o ideal para
aplicações como reconhecimento de voz, gravação de áudio embarcada,
sistemas de monitoramento acústico e dispositivos IoT com entrada
sonora. Com encapsulamento compacto e fácil integração em placas de
circuito impresso, o INMP441 oferece uma solução prática e robusta
para projetos embarcados que exigem captura de áudio de forma precisa
e eficiente.

	Para processamento e armazenamento das informacoes, foi utilizado
uma placa LORA32 da LILYGO, devida ao seu hardware integrado para uso
de cartoes SD. Isso permite a gravacao dos dados durante um grande
periodo, se considerar a disponibilidade de armazenamento no que tange
cartoes de memoria do tipo microSD.

	O dispositivo possui recomendações de alimentação de 5V pela porta
USB [17], mas por testes anteriores, é sabido que é possivel alimentar
com uma tensão superior, de até 8.1 volts, sem alterar a
funcionalidade, ou ocasionar problemas. As [baterias utilizadas](fonte),
nominalmente de 12V, conseguem fornecer 4V por célula, de maneira que
duas das células foram utilizadas.

[imagem lilygo]

Para integração dos sensores, cabeamento de rede do tipo cat6 foi
utilizado, por sua excelente condutividade, e capacidade de redução de
efeitos de interferencia, um problema comum na utilizacao de conectores[15].

	Para adaptação dos cabos CAT6, foi necessario uma pequena topologia
para interligar os sensores à placa. Outro ponto a ser citado é a
dificuldade em alimentar os sensores utilizando apenas as saídas da
placa. Foi necessário a utlização de um circuito do tipo buck,
controlado digitalmente pelo ESP, para alimentação independente dos sensores.

[imagem topologia]

[imagem conectores]

	Um total de 7 sensores foram conectados, dois do tipo SHT30,
dois BME280, dois DS18B20, e o microfone.

	Os sensores foram conectados em paralelo, permitindo que
sejam consultados sob demanda. Graças à arquitetura i2c, mais de um sensor do mesmo
tipo pode ser utilizado na mesma linha: Os dispositivos são
endereçados de fábrica, e um ou mais bits podem ser alterados
manualmente. O endereçamento é determinado por 7 bits (0b111011x),
sendo os 6 MSB (most-significant-bits) constantes, e o menos
significativo controlado pelo nivel lógico da porta SDO. A conexão
entre SDO e GND força o endereço 0b1110110 (0x76), e a conexão com
VDDIO resulta em 0b1110111 (0x77). O pino não pode flutuar.

	Se necessário, mais de dois dispositivos do
mesmo tipo poderiam ser conectados, aproveitando um detalhe da
arquitetura SPI, que utiliza um terceiro sinal (denominado CS, ou
chip-select) para controlar a seleção de um dispositivo. Neste caso, o
sinal SDO tem a mesma função do CS, mantendo todos os dispositivos com
o mesmo endereço (0x76). Quando for necessário consulta, a linha SDO
deve sofrer pull-up, alterando o endereço para 0x77, destacando-o como
tendo um endereço exclusivo, e portanto responderá individualmente. Ao
final da operação, a linha deve novamente sofrer pull-down, liberando
o canal.

	Os sensores, interligados entre si, em um primeiro teste foram
posicionados fora do mel, no sobreninho mais superior, o mais distante
do contato com os favos, prevendo possiveis problemas de funcionamento
dos sensores devido exposição ao mel e a cera.

% TODO: Falar sobre o teste de mergulhar o sensor no mel.

	O canal para transposição dos fios foi selado utilizando-se,
primeiramente, um composto de [isolante
líquido](https://www.amazon.com.br/Fita-Isolante-L\%C3\%ADquida-Bisnaga-Preta/dp/B07945ZQ32) encontrado
comercialmente. Esse produto gerou uma repulsção dos insetos em
relação ao sensor, de maneira que os efeitos da sua atividade deixaram
de ser observados, material provavelmente noscivo aos insetos. Numa segunda tentativa uma
mistura de cera de abelha derretida com própolis, extraído a partir de
outras colméias da mesma espécie. A selagem é necessária devido ao
ataque de outros insetos, em especial formigas e fungos, que se
aproveitam do ponto de abertura que os cabos provocam. A cera, quando
semi-derretida e maleável é capaz de selar a entrada dos fios, por se
moldar naturalmente à passagem de cabos, criando um canal justo, e
facilmente renovável, além de ser familiar para os indivíduos da
colônia. O própolis, por sua vez, é um poderoso antiséptico natual, o
que evita a proliferação de fungos e bactérias na região. No manejo
comum, no entanto, o selamento da entrada também é feita com fita do
tipo crepe, mas esta se degrada com a
chuva e umidade, e as abelhas ainda terão o trabalho de selar a caixa
internamente com cera e própolis.

	Finalmente, o microcontrolador, bem como uma bateria de
alimentação, foram isolados entre sí, e inseridos em frascos de
conserva, selados com resina transparente do tipo epoxi. Isso foi
necessário devido exposição à umidade. Os frascos dispostos de
ponta cabeça, de forma que a tampa ficasse embaixo, evitando que água
acumulasse proximos aos conectores. Um conector foi deixado do lado de fora, para facilitar a troca de
bateria, caso necessário.

 Eventualmente, problemas na rotina do
microcontrolador drenaram a bateria. Em algumas
ocasiões, era possível capturar o erro antes da drenagem completa, mas
isso deu origem à
necessidade de criar um sistema robusto de logging de erros, uma vez
que erros do tipo hard-fault, por padrão, resultam num loop infinito
em determinado ponto do programa, e mesmo com uso de watchdog, o erro torna a
ocorrer, e intervenção do usuário é necessária. A ideia original, é que o usuário
seja capaz de debuggar e verificar o sistema no ponto de erro, seja rodando
o programa de trás pra frente, inspecionando a memória, stack, entre
outros recursos, mas essa informação fica sujeita à capacidade do
usuário de intervir no sistema em funcionamento, dificultado no
contexto desse trabalho.

	Uma solução é o registro de alguns pontos para futura
correção: conjunto subsequente de chamadas que levou à execução até a
instrução fatal (stack), um snapshot de pontos importantes da memória,
memory-dump, eventos ocorridos, que possam ter provocado o erro,
event-log, e por fim, características físicas do dispositivo, como
temperatura, níveis de tensão e corrente, quando possível. Mas além de
tudo isso, a função original de hard-fault precisa ser reescrita, de
preferência a resetar o dispositivo.

	Para isso, a API padrão dos dispositivos ESP32 já possuem chamadas
para geração de logs, capaz de apresentar mensagens conforme a demanda
do usuário. Conforme explica [18], o sistema possui diversos níveis de
log, onde, ao configurar os parâmetros Log Level e Maximum Log Level,
podemos determinar quais mensagens aparecerão, variando, em ordem
decrescente de verbosidade, Verbose, Debug e Info até Warning, Error e
None.  Caso alguma mensagem seja configurada com uma verbosidade maior
que Maximum Log Level, a mesma não constará no binário final.

Essa habilidade, no entanto, exige uma tomada de decisão. A escrita
dos eventos pode ser feita de duas maneiras: preditiva, isto é, nos possíveis
pontos de problemas, sempre exportar mensagens; Ou remediativa, que é
verificar o código por problemas, e caso encontrado, exportar a
respectiva mensagem. O primeiro método possui o malefício de gerar
mensagens desnecessárias e exigir muitos recursos dedicados ao log. A
segunda opção, no entanto, possui a possibilidade de que um erro fatal
impeça o dispositivo de continuar funcionando, e mensagem nenhuma ser
registrada. 

% TODO: Deveria usar a ideia do Denardim, e criar uma região reservada
% para registro de logs?

% TODO: Ver como funciona o debug de um hard-fault dentro de um RTOS
 
	Para efeitos práticos, um wrapper foi criado para automatizar a
geração das mensagens de log, dando origem à uma biblioteca denominada
HERMES. Esse wrapper foi escrito de maneira que quaisquer ações
direcionadas a um sensor gerasse eventos, e os registrasse em
armazenamento de massa.

	A biblioteca possui o conceito de "object", ou "objeto", onde um objeto é
capaz de realizar determinadas tarefas, classificadas em inicializar,
configurar, consultar, e desinicializar. Essas tarefas são abstraídas
no conceito de "taskchain", ou "corrente de tarefas", onde um ou mais
métodos, ou funções, podem ser cadastradas na chain para realizar
chamadas subsequentes na ordem em que foram cadastradas. E para cada
nova chamada, um evento é gerado e armazenado.

	A captura dos dados foram feitas através de consulta sob demanda
de cada sensor, e gravação através do armazenamento utilizando uma função atômica de escrita, em um
arquivo de texto, seguindo um padrão de time-stamp

[#n][Nome]([medida][unidade])\\+

Esse padrão foi
utilizado por fornecer contexto de origem, instante e leitura de um
sensor, consideradas suficientes para a naturza desta aplicação.

	Além disso, a biblioteca foi implementada com uma análise de
requisitos, a saber

'''
* - Only it can write. Other actors must rely on this to write.
* 
* - Must write, no matter what happens (i.e. write must always
* succeed);
* 
* This means that if for any reason, the media fails to be written to,
* the actor must be able to hold-on information for long enough, or
* provide necessary means to easy the load of current write, until the
* write media goes back to normal;
* 
* - Must, while writing, lock any actor from reading it;
* 
* This is to prevent incomplete/inaccurate info retrieval (i.e. atomic
* write/read operations)
* 
* - Must, while reading, lock any actor from writing it;
* 
* - Must handle parallel writes/reads;
* 
* - Must generate its own events (be able to log itself in event-driven
* manner);
'''

	Dentre os requisitos, destacam se dois importantes: "Must write,
no matter what happens", essencial para a garantia de telemetria dos
sensores, e "must handle parallel writes/reads", conveniente à
implementação de diversos sensores para escrita e leitura simultânea.





% NOTE: Acho que não precisa da biblioteca de compactação, mas seria
% interessante falar que ela foi criada

	Para tratar do primeiro requisito, foi desenvolvida uma nova
biblioteca, afim de lidar com o problema de pouca memória presente no
micro, prevendo a possivel falha de todos os canais de comunicacoes do
sistema, por diversas razões.

	Para métodos de lidar com dados seriais, pode-se citar fila como
sendo a mais comum. A fila possui um modelo first-in, first out (FIFO)
de consulta, permitindo que n séries s de dados sejam capturados, e para
amostragem ser uniforme, os dados são amostrados numa frequencia f.

	No entanto, a lotação da memória por outros processos pode fazer
com que dados sejam perdidos, de forma que alguma série pode não ser
subsequente à outra. Para corrigir isso, uma opção é reduzir a
frequência de captura, por consequência diminuindo sua resolução, em
detrimento da garantia de captura de pelo menos um dado durante o
período em que a memória ficou lotada.

	Além disso, também é possivel o agrupamento dos dados em séries,
dado que os dados tem um intervalo bem definido de possilibdades,
bastando apenas guardar os instantes de tempo no qual o mesmo ocorre.

	Outro auxílio é possivel através do uso de média movel, para
garantia que os dados, ainda que esparços, sejam capazes de
representar a média de valores de um intervalo.

	Por fim, pode-se ainda compactar os valores, procedendo para
escrita numa mídia de armazenamento em massa, ou transmissão para
posterior consulta.

	A biblioteca, nomeada de Sparse-Buffer, possui todas as
funcionalidades citadas a cima, utilizada
	



A bateria acabar

Algum cabo falhar

Algum sensor falhar

	- como descobrir a diferença de falha do sensor, ou falha do cabo?
talvez testar um curto local

a rede falhar

 - como unificar os canais de rede em uma biblioteca só?

o armazenamento falhar











	Outro aspecto importante de pensar foi a forma de posicionar os
sensores.






Lembrar de falar que nao possuir osciloscopio disponivel em campo
dificultou muita coisa

Possivel efeito capacitivo do contato de circuito i2c com umidade

falar sobre hard-fault que engole energia no esp

falar sobre a necessidade de um debug remoto






% Achar um argumento melhor pra essa porra.


	Alem disso, a exposicao de eletronicos no mel é um assunto sem
publicações. No entanto, estende-se parte das implicações da presença
de umidade nessas aplicações.

	Um problema comum em I2C é sua sensibilidade a efeitos capacitivos
na linha

% https://www.eevblog.com/forum/projects/i2c-pcb-design-trace-length-and-interference/
%
% descobrir como a resistencia afeta o efeito de bordas na i2c

%Lembrar de falar que nao possuir osciloscopio disponivel em campo
%dificultou muita coisa

% Possivel efeito capacitivo do contato de circuito i2c com umidade

% falar sobre hard-fault que engole energia no esp

% falar sobre a necessidade de um debug remoto





[fotografia cabo de rede]

	Para consulta dos sensores, 

I2C



\subsection{Estudos}

\subsubsection{Temperatura}



\subsection{Aplicação e registro}
\subsection{Análise Comparativa}
















